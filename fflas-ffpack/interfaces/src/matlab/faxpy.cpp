/* ------------------------------------------------------------------ -*- c++ -*-
 *
 * (c) SILKAN           - 2014-2016
 *     Generated by the 'ffinterg' tool (v0.4)
 *
 * ========LICENCE========
 * This file is part of the library FFLAS-FFPACK.
 *
 * FFLAS-FFPACK is free software: you can redistribute it and/or modify
 * it under the terms of the  GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 * ========LICENCE========
 */

#include "ffintert_matlab.h"
using namespace ffintert;

void ff_faxpy(int32_t, size_t, int32_t, const int32_t*, size_t, int32_t*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(int64_t, size_t, int64_t, const int64_t*, size_t, int64_t*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(Integer, size_t, Integer, const Integer*, size_t, Integer*, size_t);
void ff_faxpy(float, size_t, float, const float*, size_t, float*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(double, size_t, double, const double*, size_t, double*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(int32_t, size_t, size_t, int32_t, const int32_t*, size_t, int32_t*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(int64_t, size_t, size_t, int64_t, const int64_t*, size_t, int64_t*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(Integer, size_t, size_t, Integer, const Integer*, size_t, Integer*, size_t);
void ff_faxpy(float, size_t, size_t, float, const float*, size_t, float*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);
void ff_faxpy(double, size_t, size_t, double, const double*, size_t, double*, size_t, FP_C_RP = FP_C_RP_ModularBalanced);



/* -------------------------------------------------------------------------- */

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
  if ((((((nrhs == 4) && isElement<int32_t>(prhs[0])) && isElement<int32_t>(prhs[1])) && isVector<int32_t>(prhs[2])) && isVector<int32_t>(prhs[3]))) {
    int32_t p = getElement<int32_t>(prhs[0]);
    int32_t alpha = getElement<int32_t>(prhs[1]);
    Vector<int32_t> X = getVector<int32_t>(prhs[2]);
    Vector<int32_t> Y = duplicateVector<int32_t>(prhs[3], plhs[0]);
    size_t n = length(X);
    check(n, length(Y), "n");
    const int32_t* _tmp_0 = constptr(X);
    size_t _tmp_1 = st(X);
    int32_t* _tmp_2 = ptr(Y);
    size_t _tmp_3 = st(Y);
    ff_faxpy(p, n, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<int64_t>(prhs[0])) && isElement<int64_t>(prhs[1])) && isVector<int64_t>(prhs[2])) && isVector<int64_t>(prhs[3]))) {
    int64_t p = getElement<int64_t>(prhs[0]);
    int64_t alpha = getElement<int64_t>(prhs[1]);
    Vector<int64_t> X = getVector<int64_t>(prhs[2]);
    Vector<int64_t> Y = duplicateVector<int64_t>(prhs[3], plhs[0]);
    size_t n = length(X);
    check(n, length(Y), "n");
    const int64_t* _tmp_0 = constptr(X);
    size_t _tmp_1 = st(X);
    int64_t* _tmp_2 = ptr(Y);
    size_t _tmp_3 = st(Y);
    ff_faxpy(p, n, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<float>(prhs[0])) && isElement<float>(prhs[1])) && isVector<float>(prhs[2])) && isVector<float>(prhs[3]))) {
    float p = getElement<float>(prhs[0]);
    float alpha = getElement<float>(prhs[1]);
    Vector<float> X = getVector<float>(prhs[2]);
    Vector<float> Y = duplicateVector<float>(prhs[3], plhs[0]);
    size_t n = length(X);
    check(n, length(Y), "n");
    const float* _tmp_0 = constptr(X);
    size_t _tmp_1 = st(X);
    float* _tmp_2 = ptr(Y);
    size_t _tmp_3 = st(Y);
    ff_faxpy(p, n, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<double>(prhs[0])) && isElement<double>(prhs[1])) && isVector<double>(prhs[2])) && isVector<double>(prhs[3]))) {
    double p = getElement<double>(prhs[0]);
    double alpha = getElement<double>(prhs[1]);
    Vector<double> X = getVector<double>(prhs[2]);
    Vector<double> Y = duplicateVector<double>(prhs[3], plhs[0]);
    size_t n = length(X);
    check(n, length(Y), "n");
    const double* _tmp_0 = constptr(X);
    size_t _tmp_1 = st(X);
    double* _tmp_2 = ptr(Y);
    size_t _tmp_3 = st(Y);
    ff_faxpy(p, n, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<int32_t>(prhs[0])) && isElement<int32_t>(prhs[1])) && isMatrix<int32_t>(prhs[2])) && isMatrix<int32_t>(prhs[3]))) {
    int32_t p = getElement<int32_t>(prhs[0]);
    int32_t alpha = getElement<int32_t>(prhs[1]);
    Matrix<int32_t> A = getMatrix<int32_t>(prhs[2]);
    Matrix<int32_t> B = duplicateMatrix<int32_t>(prhs[3], plhs[0]);
    size_t m = rows(A);
    size_t n = cols(A);
    check(m, rows(B), "m");
    check(n, cols(B), "n");
    const int32_t* _tmp_0 = constptr(A);
    size_t _tmp_1 = ld(A);
    int32_t* _tmp_2 = ptr(B);
    size_t _tmp_3 = ld(B);
    ff_faxpy(p, n, m, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<int64_t>(prhs[0])) && isElement<int64_t>(prhs[1])) && isMatrix<int64_t>(prhs[2])) && isMatrix<int64_t>(prhs[3]))) {
    int64_t p = getElement<int64_t>(prhs[0]);
    int64_t alpha = getElement<int64_t>(prhs[1]);
    Matrix<int64_t> A = getMatrix<int64_t>(prhs[2]);
    Matrix<int64_t> B = duplicateMatrix<int64_t>(prhs[3], plhs[0]);
    size_t m = rows(A);
    size_t n = cols(A);
    check(m, rows(B), "m");
    check(n, cols(B), "n");
    const int64_t* _tmp_0 = constptr(A);
    size_t _tmp_1 = ld(A);
    int64_t* _tmp_2 = ptr(B);
    size_t _tmp_3 = ld(B);
    ff_faxpy(p, n, m, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<float>(prhs[0])) && isElement<float>(prhs[1])) && isMatrix<float>(prhs[2])) && isMatrix<float>(prhs[3]))) {
    float p = getElement<float>(prhs[0]);
    float alpha = getElement<float>(prhs[1]);
    Matrix<float> A = getMatrix<float>(prhs[2]);
    Matrix<float> B = duplicateMatrix<float>(prhs[3], plhs[0]);
    size_t m = rows(A);
    size_t n = cols(A);
    check(m, rows(B), "m");
    check(n, cols(B), "n");
    const float* _tmp_0 = constptr(A);
    size_t _tmp_1 = ld(A);
    float* _tmp_2 = ptr(B);
    size_t _tmp_3 = ld(B);
    ff_faxpy(p, n, m, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else if ((((((nrhs == 4) && isElement<double>(prhs[0])) && isElement<double>(prhs[1])) && isMatrix<double>(prhs[2])) && isMatrix<double>(prhs[3]))) {
    double p = getElement<double>(prhs[0]);
    double alpha = getElement<double>(prhs[1]);
    Matrix<double> A = getMatrix<double>(prhs[2]);
    Matrix<double> B = duplicateMatrix<double>(prhs[3], plhs[0]);
    size_t m = rows(A);
    size_t n = cols(A);
    check(m, rows(B), "m");
    check(n, cols(B), "n");
    const double* _tmp_0 = constptr(A);
    size_t _tmp_1 = ld(A);
    double* _tmp_2 = ptr(B);
    size_t _tmp_3 = ld(B);
    ff_faxpy(p, n, m, alpha, _tmp_0, _tmp_1, _tmp_2, _tmp_3);
  } else {
    error("wrong arguments types (or number) for routine: faxpy.");
  }
}

