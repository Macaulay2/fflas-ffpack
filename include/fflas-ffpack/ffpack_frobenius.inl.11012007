/* -*- mode: C++; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */

/* linbox/ffpack/ffpack_charpoly_kgfast.inl
 * Copyright (C) 2006 Clement Pernet
 *
 * Written by Clement Pernet <cpernet@uwaterloo.ca>
 *
 * See COPYING for license information.
 */

#ifndef MIN
#define MIN(a,b) (a<b)?a:b
#endif

//---------------------------------------------------------------------
// Frobenius: Las Vegas algorithm to compute the Frobenius normal form over a large field
//---------------------------------------------------------------------


// 
template <class Field>
void FFPACK::CompressRows (Field& F, const size_t M,
			   typename Field::Element * A, const size_t lda,
			   typename Field::Element * tmp, const size_t ldtmp,
			   const size_t * d, const size_t nb_blocs){

	size_t currd = d[0]-1;
	size_t curri = d[0]-1;
	for (int i = 0; i< int(nb_blocs)-1; ++i){
		fcopy(F, M, tmp + i*ldtmp, 1,  A + currd*lda, 1);
		for (int j=0; j < d[i+1] -1; ++j){
			fcopy(F, M, A + (curri++)*lda, 1, A+(currd+j+1)*lda, 1);
		}
		currd += d[i+1];
	}

	for (int i=0; i < int(nb_blocs)-1; ++i){
		fcopy (F, M, A + (curri++)*lda, 1, tmp + i*ldtmp, 1);
	}
}

template <class Field>
void FFPACK::DeCompressRows (Field& F, const size_t M, const size_t N,
			     typename Field::Element * A, const size_t lda,
			     typename Field::Element * tmp, const size_t ldtmp,
			     const size_t * d, const size_t nb_blocs){
	
	for (int i=0; i<int(nb_blocs)-1; ++i)
		fcopy(F, M, tmp + i*ldtmp, 1, A + (N-nb_blocs+i)*lda, 1);
	write_field(F,cerr, tmp, nb_blocs-1, M,ldtmp);
	size_t w_idx = N - 2;
	size_t r_idx = N - nb_blocs - 1;
	for (int i = int(nb_blocs)-2; i>=0; --i){
		for (size_t j = 0; j<d[i+1]-1; ++j)
			fcopy (F, M, A + (w_idx--)*lda, 1, A + (r_idx--)*lda, 1);
		fcopy (F, M, A + (w_idx--)*lda, 1, tmp + i*ldtmp, 1);
	}
}

template <class Field>
void FFPACK::CompressRowsQA (Field& F, const size_t M,
			     typename Field::Element * A, const size_t lda,
			     typename Field::Element * tmp, const size_t ldtmp,
			     const size_t * d, const size_t nb_blocs){

	size_t currd = 0;
	size_t curri = 0;
	for (size_t i = 0; i< nb_blocs; ++i){
		fcopy(F, M, tmp + i*ldtmp, 1,  A + currd*lda, 1);
		for (size_t j=0; j < d[i] -1; ++j)
			fcopy(F, M, A + (curri++)*lda, 1, A+(currd+j+1)*lda, 1);
		currd += d[i];
	}
	for (size_t i=0; i < nb_blocs; ++i)
		fcopy (F, M, A + (curri++)*lda, 1, tmp + i*ldtmp, 1);
}

template <class Field>
void FFPACK::DeCompressRowsQA (Field& F, const size_t M, const size_t N,
			       typename Field::Element * A, const size_t lda,
			       typename Field::Element * tmp, const size_t ldtmp,
			       const size_t * d, const size_t nb_blocs){
	
	for (size_t i=0; i<nb_blocs; ++i)
		fcopy(F, M, tmp + i*ldtmp, 1, A + (N-nb_blocs+i)*lda, 1);

	size_t w_idx = N - 1;
	size_t r_idx = N - nb_blocs - 1;
	for (int i = int(nb_blocs)-1; i>=0; --i){
		for (size_t j = 0; j<d[i]-1; ++j)
			fcopy (F, M, A + (w_idx--)*lda, 1, A + (r_idx--)*lda, 1);
		fcopy (F, M, A + (w_idx--)*lda, 1, tmp + i*ldtmp, 1);
	}
}


template <class Field, class Polynomial>
std::list<Polynomial>&
FFPACK::Frobenius (const Field& F, std::list<Polynomial>& frobeniusForm, 
		   const size_t N, typename Field::Element * A, const size_t lda){
	
	static typename Field::Element one, zero, mone;
	F.init(one, 1UL);
	F.neg(mone, one);
	F.init(zero, 0UL);

	size_t * rp = new size_t[N];
	
	// Building the workplace matrix Aw
	typename Field::Element *Arp = new typename Field::Element[N*N];
	typename Field::Element *Ac = new typename Field::Element[N*N];
	typename Field::Element *K = new typename Field::Element[N*(N+1)/2];
	typename Field::Element *K2 = new typename Field::Element[N*(N+1)/2];
	size_t ldk = (N+1)/2;
	// Permutations such that
	// A = QA [ I Ac ] PA
	//        [ 0 Ac ]
	//
	// K = [ I Kc ] PK
	//     [ 0 Kc ]
	
	size_t *dA = new size_t[N]; //PA
	size_t *dK = new size_t[N];

	for (size_t i=0; i<N; ++i)
		dA[i] = 1;
	
	size_t deg = 2;
	size_t Ma = N;
	size_t Mk;
	size_t Ncurr = N;
	size_t block_idx, it_idx, i, rp_val, nb_full_blocks;
	for (size_t i=0; i < N; ++i)
		for (size_t j=0; j < Ncurr; ++j)
			*(Ac + i*N + j) = *(A + i*lda + j);
	do{
		write_field(F, cerr<<"Ac = "<<endl, Ac, Ncurr, Ma, N);
		// Computation of the rank profile
		for (size_t i=0; i < Ncurr; ++i)
			for (size_t j=0; j < Ncurr; ++j)
				*(Arp + j*N + Ncurr-i-1) = *(Ac + i*N + j);
		SpecRankProfile (F, Ma, Ncurr, Arp, N, deg-1, rp);
				
		// Computation of the degree vector dK
		cerr<<"// Computation of the degree vector dK"<<endl;
		it_idx = 0;
		rp_val = 0;
		size_t g = 0;
		block_idx = 0;
		nb_full_blocks = 0;
		cerr<<"dK = ";
		while (g<Ncurr){
			do {g++; rp_val++; it_idx++;}
			while ( (g<Ncurr ) && (rp[g] == rp_val) && (it_idx < deg ));
			dK[block_idx++] = it_idx;
			cerr<<dK[block_idx-1]<<" ";
			if (it_idx == deg)
				nb_full_blocks ++;
			it_idx=0;
			rp_val = rp[g];
		}
		cerr<<endl;
		Mk = block_idx;
		cerr<<"Mk, nb_full_blocks = "<<Mk<<" "<<nb_full_blocks<<endl;


				
		// Selection of dense colums of K 
		cerr<<"// Selection of dense colums of K "<<endl;
		for (size_t i=0; i < nb_full_blocks; ++i){
			fcopy (F, Ncurr, K+i, ldk, Ac+i, N);
		}
		//write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// K <- QK K
		cerr<<"// K <- QK K "<<endl;
		DeCompressRows (F, Mk - nb_full_blocks, Ncurr-nb_full_blocks*deg, K + nb_full_blocks*(deg-1)*ldk, ldk, Arp, N, dK+nb_full_blocks, Mk-nb_full_blocks);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);

		size_t pos = nb_full_blocks*(deg-1);
		for (size_t i = nb_full_blocks; i < Mk; ++i){
			//	cerr<<"*(K + "<<i<<") = "<<(*(K+i))<<"ldk = "<<ldk<<endl;
			for (size_t j=0; j<Ncurr; ++j)
				F.assign (*(K + i + j*ldk), zero);
			F.assign (*(K + i + (pos + dK[i]-1)*ldk), one);
			cerr<<"dA["<<i<<"] = "<<dA[i]<<endl;
			pos += dA[i];
		}
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);

		// Copying K2 <- K
		cerr<<"// Copying K2 <- K"<<endl;
		for (size_t i=0; i<Mk; ++i)
			fcopy (F, Ncurr, K2+i, ldk, K+i, ldk);
		CompressRows (F, Mk, K2 + nb_full_blocks*deg*ldk, ldk, Arp, N, dK+nb_full_blocks, Mk-nb_full_blocks);

		
		// K <- PA K
		cerr<<"// K <- PA K"<<endl;
		CompressRows (F, nb_full_blocks, K, ldk, Arp, N, dA, Ma);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// A <- newQA^T K (compress)
		cerr<<"// K <- newQA^T K (compress)"<<endl;
		CompressRowsQA (F, Ma, Ac, N, Arp, N, dA, Ma);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);

		// K <- A K
		cerr<<"// K <- A K"<<endl;
		cerr<<"C <- AB + C"<<endl;
		write_field(F,cerr<<"A = "<<endl, Ac, Ncurr-Ma, Ma, N);
		write_field(F,cerr<<"B = "<<endl, K+(Ncurr-Ma)*ldk, Ma,nb_full_blocks, ldk);
		write_field(F,cerr<<"C = "<<endl, K, Ncurr-Ma, nb_full_blocks, ldk);
		
		fgemm (F, FflasNoTrans, FflasNoTrans, Ncurr-Ma, nb_full_blocks, Ma, one, Ac, N, K+(Ncurr-Ma)*ldk, ldk, one, K, ldk);
		fgemm (F, FflasNoTrans, FflasNoTrans, Ma, nb_full_blocks, Ma, one, Ac+(Ncurr-Ma)*N, N, K+(Ncurr-Ma)*ldk, ldk, zero, Arp, N);
		for (size_t i=0; i< Ma; ++i)
			fcopy(F, nb_full_blocks, K+(Ncurr-Ma+i)*ldk, 1, Arp+i*N, 1);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// Copying the last rows of A times K
		cerr<<"// Copying the last rows of k "<<nb_full_blocks<<" "<<Mk<<endl;
		size_t offset = (deg-2)*nb_full_blocks;
		for (size_t i = nb_full_blocks; i < Mk; ++i) {
			cerr<<"dK["<<i<<"] = "<<dK[i]<<" deg = "<<deg<<endl;
			for (size_t j=0; j<Ncurr; ++j)
				F.assign(*(K+i+j*ldk), zero);
			if (dK[i] == dA[i]) // copy the column of A
				fcopy (F, Ncurr, K+i, ldk, Ac+i, N);
			else{
				F.assign (*(K + i + (offset+dK[i]-1)*ldk), one);
				cerr<<"*(K + "<<i<<" + ("<<offset <<"+dK["<<i<<"]-1)*ldk) := 1 "<<endl;
			}
			offset += dA[i]-1;
		}
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
				
		// K <- QA K
		cerr<<"// K <- QA K"<<endl;
		DeCompressRowsQA (F, Mk, Ncurr, K, ldk, Arp, N, dA, Ma);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);

		// K <- QK^T K
		cerr<<"// K <- QK^T K"<<endl;
		CompressRows (F, Mk, K + nb_full_blocks*deg*ldk, ldk, Arp, N, dK+nb_full_blocks, Mk-nb_full_blocks);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// K <- K^-1 K
		cerr<<"// K <- K^-1 K"<<endl;
		size_t *P=new size_t[Mk];
		size_t *Q=new size_t[Mk];
		LUdivine (F, FflasNonUnit, Mk, Mk , K2 + (Ncurr-Mk)*ldk, ldk, P, Q, FfpackLQUP);
		ftrsm (F, FflasLeft, FflasLower, FflasNoTrans, FflasUnit, Mk, Mk, one, K2 + (Ncurr-Mk)*ldk, ldk, K+(Ncurr-Mk)*ldk, ldk);
		ftrsm (F, FflasLeft, FflasUpper, FflasNoTrans, FflasNonUnit, Mk, Mk, one, K2+(Ncurr-Mk)*ldk, ldk, K+(Ncurr-Mk)*ldk, ldk);
		applyP (F, FflasLeft, FflasTrans, Mk, 0, Mk, K+(Ncurr-Mk)*ldk,ldk, P);
		fgemm (F, FflasNoTrans, FflasNoTrans, Ncurr-Mk, Mk, Mk, mone, K2, ldk, K+(Ncurr-Mk)*ldk,ldk, one, K, ldk);
		delete[] P;
		delete[] Q;
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// K <- PK^T K
		cerr<<"// K <- PK^T K"<<endl;
		DeCompressRows (F, Mk, Ncurr, K, ldk, Arp, N, dK, Mk);
		write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// K <- K PK (dA <- dK)
		cerr<<"// K <- K PK (dA <- dK)"<<endl;
		if (nb_full_blocks*deg < Ncurr)
			Ma = nb_full_blocks+1;
		else
			Ma = nb_full_blocks;
		
		for (size_t i=0; i< Ma; ++i)
			dA[i] = dK[i];
		//write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		// Recovery of the completed invariant factors
		cerr<<"// Recovery of the completed invariant factors"<<endl;
		offset = deg * nb_full_blocks + dK[nb_full_blocks];
		for (size_t i=nb_full_blocks+1; i<Mk; ++i)
			if (dK[i] >= 1){ 
				Polynomial * P = new Polynomial (dK [i]);
				for (size_t j=0; j < dK[i]; ++j)
					F.neg( P->operator[](j), *(K + i + (offset+j)*ldk));
				frobeniusForm.push_front(*P);
				offset += dK[i];
				Ncurr -= dK[i];
				//block_idx--;
				//Ma--;
			}
		//Mk = block_idx;
		
		//write_field(F, cerr<<"K = "<<endl, K, Ncurr, Mk, ldk);
		
		
		// A <- K
		cerr<<"// A <- K"<<endl;
		for (size_t i=0; i < Ncurr; ++i )
			fcopy (F, Mk, Ac + i*N, 1, K + i*ldk, 1);
		deg++;
	
	} while ((nb_full_blocks >= 1) && (Mk > 1));

	// Recovery of the first invariant factor
	cerr<<"// Recovery of the first invariant factor"<<endl;
	Polynomial * P = new Polynomial (dK [0]);
	for (size_t j=0; j < dK[0]; ++j)
		F.neg( P->operator[](j), *(K  + j*ldk));
	frobeniusForm.push_front(*P);
				

	return frobeniusForm;
}

